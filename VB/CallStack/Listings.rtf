{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman{\*\falt Times};}{\f27\froman\fcharset0\fprq2{\*\panose 02020404030301010803}Garamond{\*\falt Times};}
{\f29\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}LetterGothic{\*\falt Letter Gothic MT};}{\f82\froman\fcharset238\fprq2 Times New Roman CE{\*\falt Times};}{\f83\froman\fcharset204\fprq2 Times New Roman Cyr{\*\falt Times};}
{\f85\froman\fcharset161\fprq2 Times New Roman Greek{\*\falt Times};}{\f86\froman\fcharset162\fprq2 Times New Roman Tur{\*\falt Times};}{\f87\froman\fcharset177\fprq2 Times New Roman (Hebrew){\*\falt Times};}
{\f88\froman\fcharset178\fprq2 Times New Roman (Arabic){\*\falt Times};}{\f89\froman\fcharset186\fprq2 Times New Roman Baltic{\*\falt Times};}{\f298\froman\fcharset238\fprq2 Garamond CE{\*\falt Times};}
{\f299\froman\fcharset204\fprq2 Garamond Cyr{\*\falt Times};}{\f301\froman\fcharset161\fprq2 Garamond Greek{\*\falt Times};}{\f302\froman\fcharset162\fprq2 Garamond Tur{\*\falt Times};}{\f305\froman\fcharset186\fprq2 Garamond Baltic{\*\falt Times};}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\qj \li0\ri0\sl200\slmult0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\f27\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 Authorbio;}{\s16\qj \li0\ri0\widctlpar\tx240\tx420\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\sbasedon0 \snext16 Text,t;}{\s17\ql \li0\ri3240\widctlpar\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2520\tx6300\tx6660\aspalpha\aspnum\faauto\adjustright\rin3240\lin0\itap0 \f29\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17 
Listing;}}{\info{\title \'a9 2002 Visual Studio Magazine }{\author Lee Th\'e9}{\operator Nicole Pizzurro}{\creatim\yr2002\mo2\dy28\hr15\min2}{\revtim\yr2002\mo3\dy15\hr14\min49}{\printim\yr2002\mo2\dy28\hr15\min12}{\version4}{\edmins9}{\nofpages3}
{\nofwords613}{\nofchars3188}{\*\company Fawcette Technical Publications}{\nofcharsws0}{\vern8269}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1701
\dgvorigin1984\dghshow1\dgvshow1\jexpand\viewkind4\viewscale189\viewzk2\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \sbknone\pgnrestart\linex0\endnhere\sectdefaultcl 
{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s16\qj \li0\ri0\widctlpar\tx240\tx420\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\b Listing 1\tab VB6
\par Initialize the Symbol Engine
\par }{When you need to view a call stack in production code, a certain amount of initialization is required\emdash 
particularly for the symbol engine. The stackwalk API requires pointers to two functions inside this DLL. The last two executable lines of this listing save the pointers to member-level variables.
\par 
\par }\pard\plain \s17\ql \li0\ri3240\widctlpar\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2520\tx6300\tx6660\aspalpha\aspnum\faauto\adjustright\rin3240\lin0\itap0 \f29\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par Private Sub Class_Initialize()
\par \tab Dim lRet As Long
\par \tab m_hProcess = GetCurrentProcess
\par \tab lRet = SymGetOptions
\par \tab Ret = lRet Or SYMOPT_LOAD_LINES
\par \tab lRet = lRet Or SYMOPT_OMAP_FIND_NEAREST
\par \tab SymSetOptions (lRet)
\par \tab m_bInitialized = True
\par \tab bCalledFirstStackEntry = False
\par \tab If 0=SymInitialize(m_hProcess, 0&, True) Then
\par \tab \tab ' unable to initialize the Symbol engine
\par \tab \tab m_bInitialized = False
\par \tab End If
\par \tab m_ProcAddrSymFunctionTableAddress = _
\par \tab \tab GetProcAddress(DBGHELPModule, _
\par \tab \tab "SymFunctionTableAddress")
\par \tab m_ProcAddrSymGetModuleBase = _
\par \tab \tab GetProcAddress(DBGHELPModule, _
\par \tab \tab "SymGetModuleBase")
\par End Sub
\par 
\par }\pard\plain \s16\qj \li0\ri0\widctlpar\tx240\tx420\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b Listing 2\tab VB6
\par Use Public Access
\par }{Use one of the two public methods of your StackWalk class to retrieve a string that contains the call stack. Within this public method you\rquote ll find private class methods resembling the}{\b  }{FindFirstFile and FindN
extFile APIs. Call the first method, GetFirstStackEntry, to set up and initialize the API. You call the second, GetNextStackEntry, to keep walking the stack and collect the remaining items.}{\b  
\par }\pard\plain \s17\ql \li0\ri3240\widctlpar\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2520\tx6300\tx6660\aspalpha\aspnum\faauto\adjustright\rin3240\lin0\itap0 \f29\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par Public Function GetCallStack() As String
\par \tab Dim strData As String
\par \tab Dim strTemp As String
\par \tab m_bitShowInfo = bitOptFlags
\par \tab GetCallStack = vbNullString
\par \tab If m_bInitialized Then
\par \tab \tab strData = GetFirstStackEntry
\par \tab \tab If Not (m_bitShowInfo And _
\par \tab \tab \tab bitInfoFlags.ShowSymbolCallsOnStack) _
\par \tab \tab \tab Then
\par \tab \tab \tab strData = vbNullString
\par \tab \tab \tab strTemp = GetNextStackEntry
\par \tab \tab End If
\par \tab \tab strTemp = GetNextStackEntry
\par \tab \tab Do While Len(strTemp)
\par \tab \tab \tab strData = strData & vbCrLf & strTemp
\par \tab \tab \tab strTemp = GetNextStackEntry
\par \tab \tab Loop
\par \tab \tab GetCallStack = strData
\par \tab End If
\par End Function
\par 
\par }\pard\plain \s16\qj \li0\ri0\widctlpar\tx240\tx420\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b Listing 3\tab VB6
\par Set Up the StackFrame Structure
\par }{There are some rather intense user types required for getting the stackwalk API call initiated. Use these types and enums to set up the StackFrame structure.
\par }\pard\plain \s17\ql \li0\ri3240\widctlpar\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2520\tx6300\tx6660\aspalpha\aspnum\faauto\adjustright\rin3240\lin0\itap0 \f29\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par Private Type KdHelp
\par \tab Thread As Long
\par \tab ThCallbackStack As Long
\par \tab NextCallback As Long
\par \tab FramePointer As Long
\par \tab KiCallUserMode As Long
\par \tab KeUserCallbackDispatcher As Long
\par \tab SystemRangeStart As Long
\par \tab ThCallbackBStore As Long
\par \tab Reserved(7) As Long
\par End Type
\par Private Enum ADDRESS_MODE
\par \tab AddrMode1616
\par \tab AddrMode1632
\par \tab AddrModeReal
\par \tab ddrModeFlat
\par End Enum
\par Private Type Address
\par \tab Offset As Long
\par \tab Segment As Integer
\par \tab Mode As ADDRESS_MODE
\par End Type
\par Private Type StackFrame
\par \tab AddrPC As Address
\par \tab AddrReturn As Address
\par \tab AddrFrame As Address
\par \tab AddrStack As Address
\par \tab FuncTableEntry As Long
\par \tab Params(3) As Long
\par \tab Far As Long
\par \tab Virtual As Long
\par \tab Reserved(2) As Long
\par \tab KdHelp As KdHelp
\par \tab AddrBStore As Address
\par End Type
\par 
\par }\pard\plain \s16\qj \li0\ri0\widctlpar\tx240\tx420\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b Listing 4\tab VB6
\par Get the Details of Stack Items
\par }{The stack frame type is the critical element of the stack walk. You must initialize the structure with the values of the reg
isters, IP, EBP, and ESP. After the class calls the StackWalk, the address from the item on the stack is retrieved from the AddrPC.Offset element of the type. It is then passed into the private method GetSymbolInfoForAddress to get the details of the item
. 
\par }\pard\plain \s17\ql \li0\ri3240\widctlpar\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2520\tx6300\tx6660\aspalpha\aspnum\faauto\adjustright\rin3240\lin0\itap0 \f29\fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par Private Function GetFirstStackEntry() As String
\par \tab If m_bInitialized Then
\par \tab \tab m_hThread = GetCurrentThread
\par \tab \tab GetFirstStackEntry = vbNullString
\par \tab \tab With m_oStackFrame
\par \tab \tab \tab .AddrPC.Offset = GetIP.Call
\par \tab \tab \tab .AddrPC.Mode = AddrModeFlat
\par \tab \tab \tab .AddrFrame.Offset = GetEBP.Call
\par \tab \tab \tab .AddrFrame.Mode = AddrModeFlat
\par \tab \tab \tab .AddrStack.Offset = GetESP.Call
\par \tab \tab \tab .AddrStack.Mode = AddrModeFlat
\par \tab \tab End With
\par \tab \tab GetFirstStackEntry = WalkStack
\par \tab End If
\par End Function
\par WalkStack = _
\par \tab GetSymbolInfoForAddress( _
\par \tab m_oStackFrame.AddrPC.Offset, _
\par \tab m_hProcess)
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
\par }}